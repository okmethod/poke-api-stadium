function x(){return Matter.Engine.create({enableSleeping:!0,positionIterations:6,velocityIterations:4,constraintIterations:6})}function h(){return Matter.Runner.create()}function M(n,t){return Matter.Render.create({element:t,engine:n,options:{width:t.clientWidth,height:t.clientHeight,pixelRatio:1,background:"transparent",hasBounds:!1,wireframes:!1,showSleeping:!1}})}function p(n,t){const a=Matter.Mouse.create(t.canvas);return t.mouse=a,Matter.MouseConstraint.create(n,{mouse:a,constraint:{stiffness:.2,damping:0,length:0,render:{visible:!1,lineWidth:2,strokeStyle:"#00ff00"}}})}async function w(n){const t=n.clientWidth,a=n.clientHeight;function e(c,s,i,r){return[{x:c/2-r,y:-i/2,w:c+r*2,h:i},{x:c/2-r,y:s+i/2,w:c+r*2,h:i},{x:-i/2,y:s/2-r,w:i,h:s+r*2},{x:c+i/2,y:s/2-r,w:i,h:s+r*2}]}const o=e(t,a,2e3,0).map(c=>Matter.Bodies.rectangle(c.x,c.y,c.w,c.h,{isStatic:!0,render:{visible:!1}}));return Matter.Composite.add(Matter.Composite.create(),o)}function b(n,t,a,e){function o(){e.isHolding=!0,Matter.World.add(n,t)}function c(){e.isHolding=!1,Matter.World.remove(n,t)}function s(){e.isHolding=!1,t.constraint.bodyA=null,t.constraint.bodyB=null,t.mouse.position={x:-1,y:-1},Matter.World.remove(n,t)}function i(r){const l=a.getBoundingClientRect();(r.clientX<l.left||r.clientX>l.right||r.clientY<l.top||r.clientY>l.bottom)&&Matter.World.remove(n,t)}return{pointerdown:o,pointerup:c,pointerleave:s,pointermove:i}}async function u(n){const t=await d(n),a=f(t),e=g(a,t.width,t.height);return m(e)}async function d(n){return new Promise((t,a)=>{const e=new Image;e.crossOrigin="Anonymous",e.src=n,e.onload=()=>t(e),e.onerror=o=>a(o)})}function f(n){const{width:t,height:a}=n,e=document.createElement("canvas");e.width=t,e.height=a;const o=e.getContext("2d");if(!o)throw new Error("Canvas context could not be obtained");return o.drawImage(n,0,0,t,a),o.getImageData(0,0,t,a).data}function g(n,t,a){const e=[],o=new Set;function c(i,r){const l=(r*t+i)*4;return n[l+3]===0}function s(i,r){const l=`${i},${r}`;o.has(l)||(e.push({x:i,y:r}),o.add(l))}for(let i=0;i<a;i++)for(let r=0;r<t;r++)c(r,i)||((i===0||c(r,i-1))&&s(r,i),(i===a-1||c(r,i+1))&&s(r,i),(r===0||c(r-1,i))&&s(r,i),(r===t-1||c(r+1,i))&&s(r,i));return e}function m(n){const t=n.reduce((e,o)=>(e.x+=o.x,e.y+=o.y,e),{x:0,y:0});t.x/=n.length,t.y/=n.length;const a=n.map(e=>{const o=Math.atan2(e.y-t.y,e.x-t.x);return{...e,angle:o}});return a.sort((e,o)=>e.angle-o.angle),a.map(e=>({x:e.x,y:e.y}))}function y(n,t){const a=n.reduce((o,c)=>o+c.x,0)/n.length,e=n.reduce((o,c)=>o+c.y,0)/n.length;return n.map(o=>({x:a+(o.x-a)*t,y:e+(o.y-e)*t}))}async function W(n,t,a){const e=await u(n);let o=1,c=e;if(t){const s=Matter.Bounds.create(e),i=s.max.x-s.min.x,r=s.max.y-s.min.y;o=t/Math.max(i,r);const l=o*.9;c=y(e,l)}return Matter.Bodies.fromVertices(a.x,a.y,[c],{restitution:.2,friction:.1,render:{sprite:{texture:n,xScale:o,yScale:o}}})}export{h as a,M as b,p as c,w as d,b as e,W as f,x as i};
